diff --git a/dist/db/runtime/api/studio.get.dev.d.ts b/dist/db/runtime/api/studio.get.dev.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b4e45f92542b4b0588bdd732c09d7bb4b624d229
--- /dev/null
+++ b/dist/db/runtime/api/studio.get.dev.d.ts
@@ -0,0 +1,2 @@
+declare const _default: import("h3").EventHandler<import("h3").EventHandlerRequest, Promise<any>>;
+export default _default;
diff --git a/dist/db/runtime/api/studio.get.dev.mjs b/dist/db/runtime/api/studio.get.dev.mjs
new file mode 100644
index 0000000000000000000000000000000000000000..3d71152845ff621baeff91ea97015d346cfec811
--- /dev/null
+++ b/dist/db/runtime/api/studio.get.dev.mjs
@@ -0,0 +1,48 @@
+import { eventHandler, getQuery, setHeader, createError } from "h3";
+export default eventHandler(async (event) => {
+  const query = getQuery(event);
+  const port = parseInt(String(query.port)) || 4983;
+  if (port < 1 || port > 65535) {
+    throw createError({ statusCode: 400, message: "Invalid port" });
+  }
+  const fullPath = event.path?.split("?")[0] || "";
+  const path = fullPath.replace("/api/_hub/studio", "") || "/";
+  if (path !== "/" && (!/^\/[a-zA-Z0-9._-]+$/.test(path) || path.includes(".."))) {
+    throw createError({ statusCode: 400, message: "Invalid path" });
+  }
+  if (path !== "/" && path !== "") {
+    try {
+      const isBinary = path.endsWith(".svg") || path.endsWith(".png") || path.endsWith(".ico");
+      const asset = await $fetch(`https://local.drizzle.studio${path}`, {
+        responseType: isBinary ? "blob" : "text"
+      });
+      if (path.endsWith(".js")) setHeader(event, "Content-Type", "application/javascript");
+      else if (path.endsWith(".css")) setHeader(event, "Content-Type", "text/css");
+      else if (path.endsWith(".svg")) setHeader(event, "Content-Type", "image/svg+xml");
+      else if (path.endsWith(".png")) setHeader(event, "Content-Type", "image/png");
+      else if (path.endsWith(".ico")) setHeader(event, "Content-Type", "image/x-icon");
+      return asset;
+    } catch {
+      throw createError({ statusCode: 502, message: "Failed to fetch studio asset" });
+    }
+  }
+  let html;
+  try {
+    html = await $fetch("https://local.drizzle.studio/", {
+      headers: { "Accept": "text/html" }
+    });
+  } catch {
+    throw createError({ statusCode: 502, message: "Failed to fetch Drizzle Studio" });
+  }
+  let modifiedHtml = html.replace(/src="\.\/index\.js"/g, `src="/api/_hub/studio/index.js"`).replace(/href="\.\/favicon\.svg"/g, `href="/api/_hub/studio/favicon.svg"`);
+  modifiedHtml = modifiedHtml.replace(
+    "</head>",
+    `<script>
+      if (!window.location.search.includes('port=')) {
+        history.replaceState(null, '', window.location.pathname + '?port=${port}');
+      }
+    <\/script></head>`
+  );
+  setHeader(event, "Content-Type", "text/html");
+  return modifiedHtml;
+});
diff --git a/dist/module.mjs b/dist/module.mjs
index cb0df587e07404f133284b5f8d94c2a9ac46e000..73dd044f95cbc4dc13a770aca97fe2750d4f6d3d 100644
--- a/dist/module.mjs
+++ b/dist/module.mjs
@@ -1,5 +1,5 @@
 import { readFile, writeFile, mkdir } from 'node:fs/promises';
-import { logger, createResolver, addServerPlugin, getLayerDirectories, updateTemplates, addTemplate, addTypeTemplate, addServerHandler, addServerImports, addImportsDir, defineNuxtModule } from '@nuxt/kit';
+import { logger, createResolver, addServerPlugin, addServerHandler, getLayerDirectories, updateTemplates, addTemplate, addTypeTemplate, addServerImports, addImportsDir, defineNuxtModule } from '@nuxt/kit';
 import { join, resolve as resolve$1, relative } from 'pathe';
 import { defu } from 'defu';
 import { readPackageJSON, findWorkspaceDir } from 'pkg-types';
@@ -199,7 +199,7 @@ async function resolveDatabaseConfig(nuxt, hub) {
         }
         break;
       }
-      if (hub.hosting.includes("cloudflare")) {
+      if (hub.hosting.includes("cloudflare") && !nuxt.options.dev) {
         config.driver = "d1";
         break;
       }
@@ -271,6 +271,16 @@ async function setupDatabase(nuxt, hub, deps) {
     logWhenReady(nuxt, "Please run `npx nypm i @libsql/client` to use SQLite as database.", "error");
   }
   addServerPlugin(resolve("db/runtime/plugins/migrations.dev"));
+  addServerHandler({
+    handler: resolve("db/runtime/api/studio.get.dev"),
+    method: "get",
+    route: "/api/_hub/studio"
+  });
+  addServerHandler({
+    handler: resolve("db/runtime/api/studio.get.dev"),
+    method: "get",
+    route: "/api/_hub/studio/**"
+  });
   nuxt.hook("modules:done", async () => {
     await generateDatabaseSchema(nuxt, hub);
     await nuxt.callHook("hub:db:migrations:dirs", migrationsDirs);
@@ -727,8 +737,9 @@ async function launchDrizzleStudio(nuxt, hub) {
       await startStudioMySQLServer(schema, connection, { port });
     } else if (dialect === "sqlite") {
       const { startStudioSQLiteServer } = await import('drizzle-kit/api');
-      log$1.info(`Launching Drizzle Studio with SQLite...`);
-      await startStudioSQLiteServer(schema, connection, { port });
+      log$1.info(`Launching Drizzle Studio with SQLite (${driver})...`);
+      const studioConnection = driver === "d1-http" ? { driver: "d1-http", ...connection } : connection;
+      await startStudioSQLiteServer(schema, studioConnection, { port });
     } else {
       throw new Error(`Unsupported database dialect: ${dialect}`);
     }
@@ -748,7 +759,8 @@ function addDevToolsCustomTabs(nuxt, hub) {
       icon: "i-lucide-database",
       view: isReady && port ? {
         type: "iframe",
-        src: `https://local.drizzle.studio?port=${port}`
+        // Serve Drizzle Studio through Nitro proxy to avoid CORS/Private Network Access issues
+        src: `/api/_hub/studio?port=${port}`
       } : {
         type: "launch",
         description: "Launch Drizzle Studio",
